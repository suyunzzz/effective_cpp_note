# [Effective C++] Tips 50~52 自定义new和delete

>主要介绍自定义new和delete相关的内容，对应items50-52

## 一、为什么需要自定义 new 和 delete

我们在Item 49中介绍了如何自定义new的错误处理函数，以及如何为你的类重载operator new。 现在我们回到更基础的问题，为什么我们需要自定义operator new或operator delete？

* **检测使用错误**。new得到的内存如果没有delete会导致内存泄露，而多次delete又会引发未定义行为。如果自定义operator new来保存动态内存的地址列表，在delete中判断内存是否完整，便可以识别使用错误，避免程序崩溃的同时还可以记录这些错误使用的日志。
* **提高效率**。全局的new和delete被设计为通用目的（general purpose）的使用方式，通过提供自定义的new，我们可以手动维护更适合应用场景的存储策略。
收集使用信息。在继续自定义new之前，你可能需要先自定义一个new来收集地址分配信息，比如动态内存块大小是怎样分布的？分配和回收是先进先出FIFO还是后进先出LIFO？
* **实现非常规的行为**。比如考虑到安全，operator new把新申请的内存全部初始化为0.

* **其他原因**，比如抵消平台相关的字节对齐，将相关的对象放在一起等等。

通过一个例子说明自定义new来实现越界检查：

```cpp
static const int signature = 0xDEADBEEF;    // 边界符
typedef unsigned char Byte; 

void* operator new(std::size_t size) throw(std::bad_alloc) {
    // 多申请一些内存来存放占位符 
    size_t realSize = size + 2 * sizeof(int); 

    // 申请内存
    void *pMem = malloc(realSize);
    if (!pMem) throw bad_alloc(); 

    // 写入边界符
    *(reinterpret_cast<int*>(static_cast<Byte*>(pMem)+realSize-sizeof(int))) 
        = *(static_cast<int*>(pMem)) = signature;

    // 返回真正的内存区域
    return static_cast<Byte*>(pMem) + sizeof(int);
}
```
上述例子中，将边界符分别写在了内存开头和结尾

其实上述代码是有一些瑕疵的：

- Item 49提到operator new应当不断地调用new handler，上述代码中没有遵循这个惯例；
- 有些体系结构下，不同的类型被要求放在对应的内存位置。比如double的起始地址应当是8的整数倍，int的起始地址应当是4的整数倍。上述代码可能会引起运行时硬件错误。
- 起始地址对齐。C++要求动态内存的起始地址对所有类型都是字节对齐的，new和malloc都遵循这一点，然而我们返回的地址偏移了一个int。

---

## 二、如何自定义new和delete

- operator new需要无限循环地获取资源，如果没能获取则调用"new handler"，不存在"new handler"时应该抛出异常；
- operator new应该处理size == 0的情况；
- operator delete应该兼容空指针；
- operator new/delete作为成员函数应该处理size > sizeof(Base)的情况（因为继承的存在）。

### 外部operator new
Item 49指出了如何将operator new重载为类的成员函数，在此我们先看看如何实现一个外部（非成员函数）的operator new： 
1. operator new应当有正确的返回值，在内存不足时应当调用"new handler"，请求申请大小为0的内存时也可以正常执行，避免隐藏全局的（"normal form"）new。

2. 给出返回值很容易。当内存足够时，返回申请到的内存地址；当内存不足时，根据Item 49描述的规则返回空或者抛出bad_alloc异常。
3. 每次失败时调用"new handler"，并重复申请内存却不太容易。只有当"new handler"为空时才应抛出异常。
4. 申请大小为零时也应返回合法的指针。允许申请大小为零的空间确实会给编程带来方便。
考虑到上述目标，一个非成员函数的operator new大致实现如下：
```cpp
void * operator new(std::size_t size) throw(std::bad_alloc){
    if(size == 0) size = 1;
    while(true){
        // 尝试申请
        void *p = malloc(size);

        // 申请成功
        if(p) return p;

        // 申请失败，获得new handler
        new_handler h = set_new_handler(0);
        set_new_handler(h);

        if(h) (*h)();
        else throw bad_alloc();
    }
}
```
- `size == 0`时申请大小为1看起来不太合适，但它非常简单而且能正常工作。况且你不会经常申请大小为0的空间吧？
- 两次set_new_handler调用先把全局"new handler"设置为空再设置回来，**这是因为无法直接获取"new handler"，多线程环境下这里一定需要锁**。
- `while(true)`意味着这可能是一个死循环。所以Item 49提到，**"new handler"要么释放更多内存、要么安装一个新的"new handler"**，如果你实现了一个无用的"new handler"这里就是死循环了。

### 成员函数operator new

重载`operator new`为成员函数通常是**为了对某个特定的类进行动态内存管理的优化，而不是用来给它的子类用的**。 因为在实现`Base::operator new()`时，是**基于对象大小为`sizeof(Base)`来进行内存管理优化的**。
>当然，有些情况你写的Base::operator new是通用于整个class及其子类的，这时这一条规则不适用。
```cpp
class Base{
public:
    static void* operator new(std::size_t size) throw(std::bad_alloc);
};
class Derived: public Base{...};

Derived *p = new Derived;       // 调用了 Base::operator new ！
```

子类继承`Base::operator new()`之后，因为当前对象不再是假设的大小，该方法不再适合管理当前对象的内存了。 可以在`Base::operator new`中判断参数`size`，当大小不为`sizeof(Base)`时调用全局的`new`：
```cpp
void *Base::operator new(std::size_t size) throw(std::bad_alloc){
    if(size != sizeof(Base)) return ::operator new(size);
    ...
}
```

上面的代码没有检查`size == 0！`这是C++神奇的地方，大小为0的独立对象会被插入一个`char`（见`Item 39`）。 所以`sizeof(Base)`永远不会是0，所以`size == 0`的情况交给`::operator new(size)`去处理了。

这里提一下`operator new[]`，它和`operator new`具有同样的参数和返回值， 要注意的是你不要假设其中有几个对象，以及每个对象的大小是多少，所以不要操作这些还不存在的对象。因为：

1. 你不知道对象大小是什么。上面也提到了当继承发生时`size`不一定等于`sizeof(Base)`。
2. `size`实参的值可能大于这些对象的大小之和。因为`Item 16`中提到，数组的大小可能也需要存储。

### 外部operator delete
相比于`new`，实现`delete`的规则要简单很多。唯一需要注意的是`C++`保证了`delete`一个`NULL`总是安全的，你尊重该惯例即可。

同样地，先实现一个外部（非成员）的`delete`：
```cpp
void operator delete(void *rawMem) throw(){
    if(rawMem == 0) return; 
    // 释放内存
}
```

### 成员operator delete
成员函数的`delete`也很简单，但要注意如果你的`new`转发了其他`size`的申请，那么`delete`也应该转发其他`size`的申请。
```cpp
class Base{
public:
    static void * operator new(std::size_t size) throw(std::bad_alloc);
    static void operator delete(void *rawMem, std::size_t size) throw();
};
void Base::operator delete(void *rawMem, std::size_t size) throw(){
    if(rawMem == 0) return;     // 检查空指针
    if(size != sizeof(Base)){
        ::operator delete(rawMem);
    }
    // 释放内存
}
```
>注意上面的检查的是`rawMem`为空，`size`是不会为空的。

其实`size`实参的值是通过调用者的类型来推导的（如果没有虚析构函数的话）：
```cpp
Base *p = new Derived;  // 假设Base::~Base不是虚函数
delete p;               // 传入`delete(void *rawMem, std::size_t size)`的`size == sizeof(Base)`。
```
**注意，上述代码是会造成内存泄漏的。**
如果`Base::~Base()`声明为`virtual`，则上述`size`就是正确的`sizeof(Derived)`。 这也是为什么`Item 7`指出析构函数一定要声明`virtual`。

---
## 三、palcement new & palcement delete
`"placement new"`通常是专指**指定了位置的`new(std::size_t size, void *mem)`**，用于`vector`申请`capacity`剩余的可用内存。 **但广义的`"placement new"`指的是拥有额外参数的`operator new`**。

在编写placement new 和 placemane delete的时候需要注意两件事：

1. 在编写`placement new `的时候也要编写对应的`placement delete`

2. 避免隐藏他们的默认版本

### 成对的new 和 delete

当构造函数抛出异常时，`C++`会调用与`new`同样签名的`delete`来撤销`new`。但如果我们没有声明对应的`delete`：
```cpp
class Widget{
public:
    static void* operator new(std::size_t size, std::ostream& log) throw(std::bad_alloc);
    Widget(){ throw 1; }
};

Widget *p = new(std::cerr) Widget;
```
构造函数抛出了异常，`C++`运行时尝试调用`delete(void *mem, std::ostream& log)`， 但`Widget`没有提供这样的`delete`，于是**C++不会调用任何`delete`，这将导致内存泄露**。 所以在`Widget`中需要声明同样签名的`delete`：
```cpp
static void operator delete(void *mem, std::ostream& log);
```

但客户还可能直接调用`delete p`，这时`C++`运行时不会把它解释为`"placement delete"`，这样的调用会使得`Widget`抛出异常。 所以在`Widget`中不仅要声明`"placement delete"`，还要声明一个正常的`delete`。
```cpp
class Widget{
public:
    static void* operator new(std::size_t size, std::ostream& log) throw(std::bad_alloc);
    static void operator delete(void *mem, std::ostream& log);
    static void operator delete(void *mem) throw();
    Widget(){ throw 1; }
};
```

这样，无论是构造函数抛出异常，还是用户直接调用`delete p`，内存都能正确地回收了。

### 名称隐藏
在`Item 33`中提到，**类中的名称会隐藏外部的名称，子类的名称会隐藏父类的名称**。 所以当你声明一个`"placement new"`时：
```cpp
class Base{
public:
    static void* operator new(std::size_t size, std::ostream& log) throw(std::bad_alloc);
};
Base *p = new Base;     // Error!
Base *p = new (std::cerr) Base;     // OK
```

普通的`new`将会抛出异常，因为`"placement new"`隐藏了外部的`"normal new"`。同样地，当你继承时：
```cpp
class Derived: public Base{
public:
    static void* operator new(std::size_t size) throw(std::bad_alloc);  // 覆盖基类的new
};
Derived *p = new (std::clog) Derived;       // Error!
Derived *p = new Derived;       // OK
```
这是因为子类中的`"normal new"`隐藏了父类中的`"placement new"`，虽然它们的函数签名不同。 但`Item 33`中提到，按照`C++`的名称隐藏规则会隐藏所有同名`（name）`的东西，和签名无关。

### 最佳实践

为了避免全局的`"new"`被隐藏，先来了解一下`C++`提供的三种全局`"new"`：

```cpp
void* operator new(std::size_t) throw(std::bad_alloc);      // normal new
void* operator new(std::size_t, void*) throw();             // placement new
void* operator new(std::size_t, const std::nothrow_t&) throw();     // 见 Item 49
```
为了避免隐藏这些全局`"new"`，你在创建自定义的`"new"`时，也分别声明这些签名的`"new"`并调用全局的版本。 为了方便，我们可以为这些全局版本的调用声明一个父类`StandardNewDeleteForms`：
```cpp
class StandardNewDeleteForms {
public:
  // normal new/delete
  static void* operator new(std::size_t size) throw(std::bad_alloc) { return ::operator new(size); }
  static void operator delete(void *pMemory) throw() { ::operator delete(pMemory); }

  // placement new/delete
  static void* operator new(std::size_t size, void *ptr) throw() { return ::operator new(size, ptr); }
  static void operator delete(void *pMemory, void *ptr) throw() { return ::operator delete(pMemory, ptr); }

  // nothrow new/delete
  static void* operator new(std::size_t size, const std::nothrow_t& nt) throw() { return ::operator new(size, nt); }
  static void operator delete(void *pMemory, const std::nothrow_t&) throw() { ::operator delete(pMemory); }
};
```
然后在用户类型`Widget`中`using StandardNewDeleteForms::new/delete`即可使得这些函数都可见：
```cpp
class Widget: public StandardNewDeleteForms {           // inherit std forms
public:
   using StandardNewDeleteForms::operator new;         
   using StandardNewDeleteForms::operator delete;     

   static void* operator new(std::size_t size, std::ostream& log) throw(std::bad_alloc);   // 自定义 placement new
   static void operator delete(void *pMemory, std::ostream& logStream) throw();            // 对应的 placement delete
};
```

## reference

1. https://harttle.land/2015/09/22/effective-cpp-52.html


